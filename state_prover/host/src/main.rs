// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{STATE_PROVER_ELF, STATE_PROVER_ID};
use risc0_zkvm::{default_prover, Groth16Proof};
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::Write;
use std::path::Path;
mod merkleTree;
use crate::merkleTree::MerkleTree;
use alloy_primitives::U256;
use alloy_sol_types::SolValue;
use bonsai_sdk::alpha as bonsai_sdk;
use risc0_zkvm::{
    compute_image_id,
    serde::to_vec,
    sha::{Digest, Digestible},
    Assumption, ExecutorEnv, ExecutorImpl, FileSegmentRef, Receipt, Segment, SegmentRef,
};
use std::convert::TryInto;
use std::time::Duration;

use bonsai_sdk::responses::SnarkReceipt;

use std::error::Error;
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Inputs {
    pub state_t_1: String, // merkle root of the state at t+1 (all the blocks)
    pub state_t: String,   // merkle root of the state at t (all the blocks)
    pub blocks_hash: Vec<String>, // hash of each block
}

impl Inputs {
    pub fn to_bytes(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap()
    }
}

fn run_stark2snark(session_id: String) -> Result<(String, SnarkReceipt), Box<dyn Error>> {
    let client = bonsai_sdk::Client::from_env(risc0_zkvm::VERSION)?;

    let snark_uuid = client.create_snark(session_id)?;

    let snark_receipt = loop {
        let res = snark_uuid.status(&client)?;

        if res.status == "RUNNING" {
            println!("Current status: {} - continue polling...", res.status,);
            std::thread::sleep(std::time::Duration::from_secs(15));
        } else if res.status == "SUCCEEDED" {
            break res
                .output
                .expect("Bonsai response is missing SnarkReceipt.");
        } else {
            panic!(
                "Workflow exited: {} - | err: {}",
                res.status,
                res.error_msg.unwrap_or_default()
            );
        }
    };

    let snark_psd = Digest::try_from(snark_receipt.post_state_digest.as_slice())?;

    //let snark_data = (snark_uuid.uuid, snark_receipt.clone());
    let a0_bytes: [u8; 32] = snark_receipt.snark.a[0]
        .clone()
        .try_into()
        .expect("Incorrect length for a0");
    let a1_bytes: [u8; 32] = snark_receipt.snark.a[1]
        .clone()
        .try_into()
        .expect("Incorrect length for a1");
    let b0_bytes: [u8; 32] = snark_receipt.snark.b[0][0]
        .clone()
        .try_into()
        .expect("Incorrect length for b0");
    let b1_bytes: [u8; 32] = snark_receipt.snark.b[0][1]
        .clone()
        .try_into()
        .expect("Incorrect length for b1");
    let b2_bytes: [u8; 32] = snark_receipt.snark.b[1][0]
        .clone()
        .try_into()
        .expect("Incorrect length for b2");
    let b3_bytes: [u8; 32] = snark_receipt.snark.b[1][1]
        .clone()
        .try_into()
        .expect("Incorrect length for b3");
    let c0_bytes: [u8; 32] = snark_receipt.snark.c[0]
        .clone()
        .try_into()
        .expect("Incorrect length for c0");
    let c1_bytes: [u8; 32] = snark_receipt.snark.c[1]
        .clone()
        .try_into()
        .expect("Incorrect length for c1");
    let signal1_bytes: [u8; 32] = snark_receipt.snark.public[0]
        .clone()
        .try_into()
        .expect("Incorrect length for signal1");
    let signal2_bytes: [u8; 32] = snark_receipt.snark.public[1]
        .clone()
        .try_into()
        .expect("Incorrect length for signal2");
    let signal3_bytes: [u8; 32] = snark_receipt.snark.public[2]
        .clone()
        .try_into()
        .expect("Incorrect length for signal3");
    let signal4_bytes: [u8; 32] = snark_receipt.snark.public[3]
        .clone()
        .try_into()
        .expect("Incorrect length for signal4");

    let a0 = U256::from_be_bytes(a0_bytes);
    let a1 = U256::from_be_bytes(a1_bytes);
    let b0 = U256::from_be_bytes(b0_bytes);
    let b1 = U256::from_be_bytes(b1_bytes);
    let b2 = U256::from_be_bytes(b2_bytes);
    let b3 = U256::from_be_bytes(b3_bytes);
    let c0 = U256::from_be_bytes(c0_bytes);
    let c1 = U256::from_be_bytes(c1_bytes);
    let signal1 = U256::from_be_bytes(signal1_bytes);
    let signal2 = U256::from_be_bytes(signal2_bytes);
    let signal3 = U256::from_be_bytes(signal3_bytes);
    let signal4 = U256::from_be_bytes(signal4_bytes);

    println!("a0: {}", a0.to_string());
    println!("a1: {}", a1.to_string());
    println!("b0: {}", b0.to_string());
    println!("b1: {}", b1.to_string());
    println!("b2: {}", b2.to_string());
    println!("b3: {}", b3.to_string());
    println!("c0: {}", c0.to_string());
    println!("c1: {}", c1.to_string());
    println!("signal1: {}", signal1.to_string());
    println!("signal2: {}", signal2.to_string());
    println!("signal3: {}", signal3.to_string());
    println!("signal4: {}", signal4.to_string());

    //println!("Snark data: {:?}", snark_data);
    Ok((snark_uuid.uuid, snark_receipt))
}

fn run_bonsai(input_data: Vec<u8>) -> Result<String, Box<dyn Error>> {
    let client = bonsai_sdk::Client::from_env(risc0_zkvm::VERSION)?;

    // Compute the image_id, then upload the ELF with the image_id as its key.
    let image_id = hex::encode(compute_image_id(STATE_PROVER_ELF)?);
    client.upload_img(&image_id, STATE_PROVER_ELF.to_vec())?;

    // Prepare input data and upload it.
    let input_data = to_vec(&input_data).unwrap();
    let input_data = bytemuck::cast_slice(&input_data).to_vec();
    let input_id = client.upload_input(input_data)?;

    // Add a list of assumptions
    let assumptions: Vec<String> = vec![];

    // Start a session running the prover
    let session = client.create_session(image_id, input_id, assumptions)?;
    loop {
        let res = session.status(&client)?;
        if res.status == "RUNNING" {
            eprintln!(
                "Current status: {} - state: {} - continue polling...",
                res.status,
                res.state.unwrap_or_default()
            );
            std::thread::sleep(Duration::from_secs(15));
            continue;
        }
        if res.status == "SUCCEEDED" {
            // Download the receipt, containing the output
            let receipt_url = res
                .receipt_url
                .expect("API error, missing receipt on completed session");

            let receipt_buf = client.download(&receipt_url)?;
            let receipt: Receipt = bincode::deserialize(&receipt_buf)?;
            receipt
                .verify(STATE_PROVER_ID)
                .expect("Receipt verification failed");
            println!("Proof verified!");
        } else {
            panic!(
                "Workflow exited: {} - | err: {}",
                res.status,
                res.error_msg.unwrap_or_default()
            );
        }

        break;
    }
    return Ok(session.uuid);
}

fn verify_on_chain(){
    
}

fn main() {
    let input = Inputs {
        state_t_1: "71d8979cbfae9b197a4fbcc7d387b1fae9560e2f284d30b4e90c80f6bc074f57".to_string(),
        state_t: "1".to_string(),
        blocks_hash: vec!["2".to_string()],
    };
    let input_data = (input.to_bytes());
    let session_uuid = run_bonsai(input_data).unwrap();
    let snark_data = run_stark2snark(session_uuid).unwrap();
    println!("Snark data: {:?}", snark_data);
}
